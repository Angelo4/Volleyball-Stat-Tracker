{"ast":null,"code":"\"use strict\";\n\nfunction _typeof(obj) {\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = undoable;\n\nvar debug = _interopRequireWildcard(require(\"./debug\"));\n\nvar _actions = require(\"./actions\");\n\nvar _helpers = require(\"./helpers\");\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== \"function\") return null;\n  var cache = new WeakMap();\n\n  _getRequireWildcardCache = function _getRequireWildcardCache() {\n    return cache;\n  };\n\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") {\n    return {\n      \"default\": obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache();\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj[\"default\"] = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  }\n}\n\nfunction createHistory(state, ignoreInitialState) {\n  // ignoreInitialState essentially prevents the user from undoing to the\n  // beginning, in the case that the undoable reducer handles initialization\n  // in a way that can't be redone simply\n  var history = (0, _helpers.newHistory)([], state, []);\n\n  if (ignoreInitialState) {\n    history._latestUnfiltered = null;\n  }\n\n  return history;\n} // insert: insert `state` into history, which means adding the current state\n//         into `past`, setting the new `state` as `present` and erasing\n//         the `future`.\n\n\nfunction insert(history, state, limit, group) {\n  var lengthWithoutFuture = history.past.length + 1;\n  debug.log('inserting', state);\n  debug.log('new free: ', limit - lengthWithoutFuture);\n  var past = history.past,\n      _latestUnfiltered = history._latestUnfiltered;\n  var isHistoryOverflow = limit && limit <= lengthWithoutFuture;\n  var pastSliced = past.slice(isHistoryOverflow ? 1 : 0);\n  var newPast = _latestUnfiltered != null ? [].concat(_toConsumableArray(pastSliced), [_latestUnfiltered]) : pastSliced;\n  return (0, _helpers.newHistory)(newPast, state, [], group);\n} // jumpToFuture: jump to requested index in future history\n\n\nfunction jumpToFuture(history, index) {\n  if (index < 0 || index >= history.future.length) return history;\n  var past = history.past,\n      future = history.future,\n      _latestUnfiltered = history._latestUnfiltered;\n  var newPast = [].concat(_toConsumableArray(past), [_latestUnfiltered], _toConsumableArray(future.slice(0, index)));\n  var newPresent = future[index];\n  var newFuture = future.slice(index + 1);\n  return (0, _helpers.newHistory)(newPast, newPresent, newFuture);\n} // jumpToPast: jump to requested index in past history\n\n\nfunction jumpToPast(history, index) {\n  if (index < 0 || index >= history.past.length) return history;\n  var past = history.past,\n      future = history.future,\n      _latestUnfiltered = history._latestUnfiltered;\n  var newPast = past.slice(0, index);\n  var newFuture = [].concat(_toConsumableArray(past.slice(index + 1)), [_latestUnfiltered], _toConsumableArray(future));\n  var newPresent = past[index];\n  return (0, _helpers.newHistory)(newPast, newPresent, newFuture);\n} // jump: jump n steps in the past or forward\n\n\nfunction jump(history, n) {\n  if (n > 0) return jumpToFuture(history, n - 1);\n  if (n < 0) return jumpToPast(history, history.past.length + n);\n  return history;\n} // helper to dynamically match in the reducer's switch-case\n\n\nfunction actionTypeAmongClearHistoryType(actionType, clearHistoryType) {\n  return clearHistoryType.indexOf(actionType) > -1 ? actionType : !actionType;\n} // redux-undo higher order reducer\n\n\nfunction undoable(reducer) {\n  var rawConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  debug.set(rawConfig.debug);\n\n  var config = _objectSpread({\n    limit: undefined,\n    filter: function filter() {\n      return true;\n    },\n    groupBy: function groupBy() {\n      return null;\n    },\n    undoType: _actions.ActionTypes.UNDO,\n    redoType: _actions.ActionTypes.REDO,\n    jumpToPastType: _actions.ActionTypes.JUMP_TO_PAST,\n    jumpToFutureType: _actions.ActionTypes.JUMP_TO_FUTURE,\n    jumpType: _actions.ActionTypes.JUMP,\n    neverSkipReducer: false,\n    ignoreInitialState: false,\n    syncFilter: false\n  }, rawConfig, {\n    initTypes: (0, _helpers.parseActions)(rawConfig.initTypes, ['@@redux-undo/INIT']),\n    clearHistoryType: (0, _helpers.parseActions)(rawConfig.clearHistoryType, [_actions.ActionTypes.CLEAR_HISTORY])\n  }); // Allows the user to call the reducer with redux-undo specific actions\n\n\n  var skipReducer = config.neverSkipReducer ? function (res, action) {\n    for (var _len = arguments.length, slices = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      slices[_key - 2] = arguments[_key];\n    }\n\n    return _objectSpread({}, res, {\n      present: reducer.apply(void 0, [res.present, action].concat(slices))\n    });\n  } : function (res) {\n    return res;\n  };\n  var initialState;\n  return function () {\n    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialState;\n    var action = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    debug.start(action, state);\n    var history = state;\n\n    for (var _len2 = arguments.length, slices = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n      slices[_key2 - 2] = arguments[_key2];\n    }\n\n    if (!initialState) {\n      debug.log('history is uninitialized');\n\n      if (state === undefined) {\n        var createHistoryAction = {\n          type: '@@redux-undo/CREATE_HISTORY'\n        };\n        var start = reducer.apply(void 0, [state, createHistoryAction].concat(slices));\n        history = createHistory(start, config.ignoreInitialState);\n        debug.log('do not set initialState on probe actions');\n        debug.end(history);\n        return history;\n      } else if ((0, _helpers.isHistory)(state)) {\n        history = initialState = config.ignoreInitialState ? state : (0, _helpers.newHistory)(state.past, state.present, state.future);\n        debug.log('initialHistory initialized: initialState is a history', initialState);\n      } else {\n        history = initialState = createHistory(state, config.ignoreInitialState);\n        debug.log('initialHistory initialized: initialState is not a history', initialState);\n      }\n    }\n\n    var res;\n\n    switch (action.type) {\n      case undefined:\n        return history;\n\n      case config.undoType:\n        res = jump(history, -1);\n        debug.log('perform undo');\n        debug.end(res);\n        return skipReducer.apply(void 0, [res, action].concat(slices));\n\n      case config.redoType:\n        res = jump(history, 1);\n        debug.log('perform redo');\n        debug.end(res);\n        return skipReducer.apply(void 0, [res, action].concat(slices));\n\n      case config.jumpToPastType:\n        res = jumpToPast(history, action.index);\n        debug.log(\"perform jumpToPast to \".concat(action.index));\n        debug.end(res);\n        return skipReducer.apply(void 0, [res, action].concat(slices));\n\n      case config.jumpToFutureType:\n        res = jumpToFuture(history, action.index);\n        debug.log(\"perform jumpToFuture to \".concat(action.index));\n        debug.end(res);\n        return skipReducer.apply(void 0, [res, action].concat(slices));\n\n      case config.jumpType:\n        res = jump(history, action.index);\n        debug.log(\"perform jump to \".concat(action.index));\n        debug.end(res);\n        return skipReducer.apply(void 0, [res, action].concat(slices));\n\n      case actionTypeAmongClearHistoryType(action.type, config.clearHistoryType):\n        res = createHistory(history.present, config.ignoreInitialState);\n        debug.log('perform clearHistory');\n        debug.end(res);\n        return skipReducer.apply(void 0, [res, action].concat(slices));\n\n      default:\n        res = reducer.apply(void 0, [history.present, action].concat(slices));\n\n        if (config.initTypes.some(function (actionType) {\n          return actionType === action.type;\n        })) {\n          debug.log('reset history due to init action');\n          debug.end(initialState);\n          return initialState;\n        }\n\n        if (history._latestUnfiltered === res) {\n          // Don't handle this action. Do not call debug.end here,\n          // because this action should not produce side effects to the console\n          return history;\n        }\n        /* eslint-disable-next-line no-case-declarations */\n\n\n        var filtered = typeof config.filter === 'function' && !config.filter(action, res, history);\n\n        if (filtered) {\n          // if filtering an action, merely update the present\n          var filteredState = (0, _helpers.newHistory)(history.past, res, history.future, history.group);\n\n          if (!config.syncFilter) {\n            filteredState._latestUnfiltered = history._latestUnfiltered;\n          }\n\n          debug.log('filter ignored action, not storing it in past');\n          debug.end(filteredState);\n          return filteredState;\n        }\n        /* eslint-disable-next-line no-case-declarations */\n\n\n        var group = config.groupBy(action, res, history);\n\n        if (group != null && group === history.group) {\n          // if grouping with the previous action, only update the present\n          var groupedState = (0, _helpers.newHistory)(history.past, res, history.future, history.group);\n          debug.log('groupBy grouped the action with the previous action');\n          debug.end(groupedState);\n          return groupedState;\n        } // If the action wasn't filtered or grouped, insert normally\n\n\n        history = insert(history, res, config.limit, group);\n        debug.log('inserted new state into history');\n        debug.end(history);\n        return history;\n    }\n  };\n}","map":{"version":3,"names":["_typeof","obj","Symbol","iterator","constructor","prototype","Object","defineProperty","exports","value","undoable","debug","_interopRequireWildcard","require","_actions","_helpers","_getRequireWildcardCache","WeakMap","cache","__esModule","has","get","newObj","hasPropertyDescriptor","getOwnPropertyDescriptor","key","hasOwnProperty","call","desc","set","ownKeys","object","enumerableOnly","keys","getOwnPropertySymbols","symbols","filter","sym","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","_defineProperty","getOwnPropertyDescriptors","defineProperties","configurable","writable","_toConsumableArray","arr","_arrayWithoutHoles","_iterableToArray","_nonIterableSpread","TypeError","iter","toString","Array","from","isArray","arr2","createHistory","state","ignoreInitialState","history","newHistory","_latestUnfiltered","insert","limit","group","lengthWithoutFuture","past","log","isHistoryOverflow","pastSliced","slice","newPast","concat","jumpToFuture","index","future","newPresent","newFuture","jumpToPast","jump","n","actionTypeAmongClearHistoryType","actionType","clearHistoryType","indexOf","reducer","rawConfig","undefined","config","groupBy","undoType","ActionTypes","UNDO","redoType","REDO","jumpToPastType","JUMP_TO_PAST","jumpToFutureType","JUMP_TO_FUTURE","jumpType","JUMP","neverSkipReducer","syncFilter","initTypes","parseActions","CLEAR_HISTORY","skipReducer","res","action","_len","slices","_key","present","initialState","start","_len2","_key2","createHistoryAction","type","end","isHistory","some","filtered","filteredState","groupedState"],"sources":["/Users/angeloalcantara/Projects/Volleyball-Stat-Tracker/volleyball-stat-tracker-app/node_modules/redux-undo/lib/reducer.js"],"sourcesContent":["\"use strict\";\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = undoable;\n\nvar debug = _interopRequireWildcard(require(\"./debug\"));\n\nvar _actions = require(\"./actions\");\n\nvar _helpers = require(\"./helpers\");\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") { return { \"default\": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj[\"default\"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance\"); }\n\nfunction _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }\n\nfunction createHistory(state, ignoreInitialState) {\n  // ignoreInitialState essentially prevents the user from undoing to the\n  // beginning, in the case that the undoable reducer handles initialization\n  // in a way that can't be redone simply\n  var history = (0, _helpers.newHistory)([], state, []);\n\n  if (ignoreInitialState) {\n    history._latestUnfiltered = null;\n  }\n\n  return history;\n} // insert: insert `state` into history, which means adding the current state\n//         into `past`, setting the new `state` as `present` and erasing\n//         the `future`.\n\n\nfunction insert(history, state, limit, group) {\n  var lengthWithoutFuture = history.past.length + 1;\n  debug.log('inserting', state);\n  debug.log('new free: ', limit - lengthWithoutFuture);\n  var past = history.past,\n      _latestUnfiltered = history._latestUnfiltered;\n  var isHistoryOverflow = limit && limit <= lengthWithoutFuture;\n  var pastSliced = past.slice(isHistoryOverflow ? 1 : 0);\n  var newPast = _latestUnfiltered != null ? [].concat(_toConsumableArray(pastSliced), [_latestUnfiltered]) : pastSliced;\n  return (0, _helpers.newHistory)(newPast, state, [], group);\n} // jumpToFuture: jump to requested index in future history\n\n\nfunction jumpToFuture(history, index) {\n  if (index < 0 || index >= history.future.length) return history;\n  var past = history.past,\n      future = history.future,\n      _latestUnfiltered = history._latestUnfiltered;\n  var newPast = [].concat(_toConsumableArray(past), [_latestUnfiltered], _toConsumableArray(future.slice(0, index)));\n  var newPresent = future[index];\n  var newFuture = future.slice(index + 1);\n  return (0, _helpers.newHistory)(newPast, newPresent, newFuture);\n} // jumpToPast: jump to requested index in past history\n\n\nfunction jumpToPast(history, index) {\n  if (index < 0 || index >= history.past.length) return history;\n  var past = history.past,\n      future = history.future,\n      _latestUnfiltered = history._latestUnfiltered;\n  var newPast = past.slice(0, index);\n  var newFuture = [].concat(_toConsumableArray(past.slice(index + 1)), [_latestUnfiltered], _toConsumableArray(future));\n  var newPresent = past[index];\n  return (0, _helpers.newHistory)(newPast, newPresent, newFuture);\n} // jump: jump n steps in the past or forward\n\n\nfunction jump(history, n) {\n  if (n > 0) return jumpToFuture(history, n - 1);\n  if (n < 0) return jumpToPast(history, history.past.length + n);\n  return history;\n} // helper to dynamically match in the reducer's switch-case\n\n\nfunction actionTypeAmongClearHistoryType(actionType, clearHistoryType) {\n  return clearHistoryType.indexOf(actionType) > -1 ? actionType : !actionType;\n} // redux-undo higher order reducer\n\n\nfunction undoable(reducer) {\n  var rawConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  debug.set(rawConfig.debug);\n\n  var config = _objectSpread({\n    limit: undefined,\n    filter: function filter() {\n      return true;\n    },\n    groupBy: function groupBy() {\n      return null;\n    },\n    undoType: _actions.ActionTypes.UNDO,\n    redoType: _actions.ActionTypes.REDO,\n    jumpToPastType: _actions.ActionTypes.JUMP_TO_PAST,\n    jumpToFutureType: _actions.ActionTypes.JUMP_TO_FUTURE,\n    jumpType: _actions.ActionTypes.JUMP,\n    neverSkipReducer: false,\n    ignoreInitialState: false,\n    syncFilter: false\n  }, rawConfig, {\n    initTypes: (0, _helpers.parseActions)(rawConfig.initTypes, ['@@redux-undo/INIT']),\n    clearHistoryType: (0, _helpers.parseActions)(rawConfig.clearHistoryType, [_actions.ActionTypes.CLEAR_HISTORY])\n  }); // Allows the user to call the reducer with redux-undo specific actions\n\n\n  var skipReducer = config.neverSkipReducer ? function (res, action) {\n    for (var _len = arguments.length, slices = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      slices[_key - 2] = arguments[_key];\n    }\n\n    return _objectSpread({}, res, {\n      present: reducer.apply(void 0, [res.present, action].concat(slices))\n    });\n  } : function (res) {\n    return res;\n  };\n  var initialState;\n  return function () {\n    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialState;\n    var action = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    debug.start(action, state);\n    var history = state;\n\n    for (var _len2 = arguments.length, slices = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n      slices[_key2 - 2] = arguments[_key2];\n    }\n\n    if (!initialState) {\n      debug.log('history is uninitialized');\n\n      if (state === undefined) {\n        var createHistoryAction = {\n          type: '@@redux-undo/CREATE_HISTORY'\n        };\n        var start = reducer.apply(void 0, [state, createHistoryAction].concat(slices));\n        history = createHistory(start, config.ignoreInitialState);\n        debug.log('do not set initialState on probe actions');\n        debug.end(history);\n        return history;\n      } else if ((0, _helpers.isHistory)(state)) {\n        history = initialState = config.ignoreInitialState ? state : (0, _helpers.newHistory)(state.past, state.present, state.future);\n        debug.log('initialHistory initialized: initialState is a history', initialState);\n      } else {\n        history = initialState = createHistory(state, config.ignoreInitialState);\n        debug.log('initialHistory initialized: initialState is not a history', initialState);\n      }\n    }\n\n    var res;\n\n    switch (action.type) {\n      case undefined:\n        return history;\n\n      case config.undoType:\n        res = jump(history, -1);\n        debug.log('perform undo');\n        debug.end(res);\n        return skipReducer.apply(void 0, [res, action].concat(slices));\n\n      case config.redoType:\n        res = jump(history, 1);\n        debug.log('perform redo');\n        debug.end(res);\n        return skipReducer.apply(void 0, [res, action].concat(slices));\n\n      case config.jumpToPastType:\n        res = jumpToPast(history, action.index);\n        debug.log(\"perform jumpToPast to \".concat(action.index));\n        debug.end(res);\n        return skipReducer.apply(void 0, [res, action].concat(slices));\n\n      case config.jumpToFutureType:\n        res = jumpToFuture(history, action.index);\n        debug.log(\"perform jumpToFuture to \".concat(action.index));\n        debug.end(res);\n        return skipReducer.apply(void 0, [res, action].concat(slices));\n\n      case config.jumpType:\n        res = jump(history, action.index);\n        debug.log(\"perform jump to \".concat(action.index));\n        debug.end(res);\n        return skipReducer.apply(void 0, [res, action].concat(slices));\n\n      case actionTypeAmongClearHistoryType(action.type, config.clearHistoryType):\n        res = createHistory(history.present, config.ignoreInitialState);\n        debug.log('perform clearHistory');\n        debug.end(res);\n        return skipReducer.apply(void 0, [res, action].concat(slices));\n\n      default:\n        res = reducer.apply(void 0, [history.present, action].concat(slices));\n\n        if (config.initTypes.some(function (actionType) {\n          return actionType === action.type;\n        })) {\n          debug.log('reset history due to init action');\n          debug.end(initialState);\n          return initialState;\n        }\n\n        if (history._latestUnfiltered === res) {\n          // Don't handle this action. Do not call debug.end here,\n          // because this action should not produce side effects to the console\n          return history;\n        }\n        /* eslint-disable-next-line no-case-declarations */\n\n\n        var filtered = typeof config.filter === 'function' && !config.filter(action, res, history);\n\n        if (filtered) {\n          // if filtering an action, merely update the present\n          var filteredState = (0, _helpers.newHistory)(history.past, res, history.future, history.group);\n\n          if (!config.syncFilter) {\n            filteredState._latestUnfiltered = history._latestUnfiltered;\n          }\n\n          debug.log('filter ignored action, not storing it in past');\n          debug.end(filteredState);\n          return filteredState;\n        }\n        /* eslint-disable-next-line no-case-declarations */\n\n\n        var group = config.groupBy(action, res, history);\n\n        if (group != null && group === history.group) {\n          // if grouping with the previous action, only update the present\n          var groupedState = (0, _helpers.newHistory)(history.past, res, history.future, history.group);\n          debug.log('groupBy grouped the action with the previous action');\n          debug.end(groupedState);\n          return groupedState;\n        } // If the action wasn't filtered or grouped, insert normally\n\n\n        history = insert(history, res, config.limit, group);\n        debug.log('inserted new state into history');\n        debug.end(history);\n        return history;\n    }\n  };\n}"],"mappings":"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"},"metadata":{},"sourceType":"script"}